# API 接口与业务逻辑说明

本文档介绍 Gallery 后端提供的 API 接口及其背后的业务意义，特别是它们与扫描机制 (`Scanner`) 的交互。

## 1. 核心设计理念

Gallery 的 API 设计遵循 **“读写分离”** 与 **“被动刷新”** 的原则：

1.  **基于内存树的读取**：所有的 GET 请求（浏览、获取图片列表）都直接由内存中的 `TraverseNode` 树提供服务。这意味着 API 响应极其迅速，不涉及即时的磁盘 I/O（除了文件本身的服务）。
2.  **被动触发扫描**：为了保证数据的新鲜度，主要的浏览接口在被调用时会触发 `Trigger()` 方法。如果距离上次扫描超过一定时间（当前设定为 300秒），后台将启动异步扫描更新内存树。

## 2. 接口详解

以下接口均定义在 `gallery.go` 中。

### 2.1 获取目录树结构
**路径**: `/api/tree`
**参数**: `leaf` (bool, 默认 true)

*   **业务逻辑**: 返回整个图库的目录层级结构。
*   **用途**: 用于前端的侧边栏导航或文件夹选择器。
*   **注意**: 即使 `leaf` 为 true，此接口通常只返回目录结构，用于快速生成导航树。

### 2.2 浏览目录内容
**路径**: `/api/explore/*name`
**参数**: `name` (完整目录路径)

*   **业务逻辑**:
    1.  调用 `Trigger()` 尝试触发后台刷新。
    2.  在内存树中定位到指定路径的节点。
    3.  返回该节点下的**直接子项**：包括子文件夹 (`directories`)、图片 (`images`)、视频 (`videos`) 与其他文件 (`others`)。
*   **用途**: 这是最主要的文件浏览器视图接口。当用户点击进入某个文件夹时调用。
*   **注意**: 如果该目录下没有对应类型的项，对应的字段将返回 `[]` 而不是 `null`，以确保前端解构和循环的稳定性。

### 2.3 获取递归媒体列表
**路径**: `/api/media/*name`
**参数**: 
    *   `name`: 目录路径。
    *   `flat` (bool, 默认 true): 是否展平（递归包含子目录）。
**业务逻辑**:
    1.  调用 `Trigger()` 尝试触发后台刷新。
    2.  返回该目录下（根据 `flat` 参数决定是否递归）的所有图片 (`images`) 和视频 (`videos`) 节点。
    3.  视频节点会尝试补全元数据（时长、宽高）。
*   **用途**: 用于相册视图或视频列表视图。

### 2.4 获取递归图片列表
**路径**: `/api/image/*name`
**参数**: `name` (完整目录路径)

*   **业务逻辑**:
    1.  调用 `Trigger()` 尝试触发后台刷新。
    2.  返回该目录下（包含所有子目录）的所有图片节点。
*   **用途**: 用于“瀑布流”视图或“幻灯片”模式。
*   **注意**: 这是一个历史遗留接口，建议新功能优先使用 `/api/media`。

### 2.5 获取递归相册列表
**路径**: `/api/album/*name`
**参数**: `name` (完整目录路径)

*   **业务逻辑**:
    1.  调用 `Trigger()` 尝试触发后台刷新。
    2.  返回该目录下所有包含图片的子目录（即“相册”）。
*   **用途**: 用于相册墙视图，展示有哪些子文件夹包含图片。

### 2.6 随机图片
**路径**: `/api/random/*name`
**参数**:
    *   `name`: 限定在哪个目录下随机。
    *   `flat` (bool, 默认 true): 是否包括子目录。
*   **业务逻辑**: 在指定节点及其子树中随机抽取一张图片。为了保证性能和随机性，系统会尝试多次随机查找（Retry 机制）。
*   **用途**: 用于生成动态封面、随机背景或“手气不错”功能。注意此接口**不触发** Rescan。

## 3. 静态资源路由

除了 `/api` 接口外，系统还提供以下静态资源路由：

### 3.1 图片原图/缩略图
*   **原图**: `/file/*path`
*   **缩略图**: `/thumbnail/*path`
    *   如果缓存不存在，将异步生成。

### 3.2 视频与封面
*   **视频流**: `/video/*path`
    *   仅允许白名单中的视频格式：`.mp4`, `.mkv`, `.webm`, `.avi`, `.mov`。
*   **视频封面**: `/poster/*path`
    *   **优先级**: 
        1.  如果视频同目录下存在 `cover.jpg/jpeg/png/webp`，优先返回该文件。
        2.  否则，使用 `ffmpeg` 抽取视频第 5 秒的帧作为封面，并缓存于 `.cache/` 目录下。

## 4. 约定与最佳实践

1.  **空数组约定**: 所有返回列表的字段（`images`, `videos`, `directories`, `others`），在无数据或扫描未完成时，必须返回 `[]` 而非 `null`。
2.  **URL 编码**: 路径参数 `*name` 可能包含空格或特殊字符，前端请求时应进行 URL 编码（如 `encodeURIComponent`）。
3.  **示例**:
    *   获取 `Holiday 2024` 目录下的媒体：
        `curl "http://localhost:8080/api/media/Holiday%202024?flat=true"`
    *   获取视频封面：
        `<img src="/poster/Holiday%202024/video.mp4" />`

## 5. 扫描触发机制 (Relation to Core)

正如 `docs/scanning_mechanism.md` 所述，上述接口（Explore, Image, Album）集成了自动的刷新机制：

```go
func (g *Gallery) Trigger() {
    // 只有当距离上次扫描超过 300 秒时才尝试
    if (time.Now().Unix() - g.lastScan) > 300 {
        // 非阻塞发送：如果 Scanner 正在忙，则忽略本次触发
        // ...
    }
}
```

*   **防抖与节流**: 这种机制确保了即使 API 被高频调用（例如爬虫或快速点击），后台扫描也不会过载。
*   **最终一致性**: 用户第一次访问可能会看到旧数据（如果是冷启动且未完成预热），但随即触发的扫描会在后台完成后更新内存树，下次刷新即可看到最新内容。

## 6. 总结

| 接口 | 作用 | 是否触发扫描 | 典型场景 |
| :--- | :--- | :--- | :--- |
| `/api/tree` | 导航树结构 | 否 | 侧边栏加载 |
| `/api/explore` | 直接子项（目录/图/影） | **是** | 进入文件夹 |
| `/api/media` | 递归/非递归媒体列表 | **是** | 相册/视频列表 |
| `/api/image` | 递归图片列表 (Legacy) | **是** | 瀑布流浏览 |
| `/api/album` | 递归子相册列表 | **是** | 相册概览 |
| `/api/random` | 随机图片取样 | 否 | 随机封面 |
| `/video` | 视频文件流 | 否 | 视频播放 |
| `/poster` | 视频封面 (抽帧/Cover) | 否 | 视频预览 |

前端通过组合使用这些接口，配合后台的被动扫描机制，实现了流畅且相对实时的浏览体验。
